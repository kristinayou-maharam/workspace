<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compare - Infinite Canvas Board</title>
  <link rel="stylesheet" href="src/styles.css">
  <style>
    body {
      background: #ffffff;
    }

    .compare-container {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100vh;
      background: #ffffff;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .compare-scroll-wrapper {
      display: flex;
      height: 100vh;
      min-width: 100%;
      padding: 20px 40px 40px 40px;
      gap: 0;
    }

    .compare-column {
      min-width: 300px;
      max-width: 300px;
      height: calc(100vh - 60px);
      background: #ffffff;
      border-right: 1px solid #e8e8e8;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .compare-column-header {
      padding: 20px 20px 16px 20px;
      background: white;
      border-bottom: 1px solid #e8e8e8;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .compare-column-title {
      font-size: 13px;
      font-weight: 400;
      color: #000;
      margin-bottom: 4px;
      font-family: "MaharamNeue-Regular", sans-serif;
    }

    .compare-column-subtitle {
      font-size: 11px;
      color: #666;
      font-weight: 300;
    }

    .compare-column-content {
      padding: 0;
      flex: 1;
    }

    .compare-product-image {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
      border-radius: 0;
      margin-bottom: 0;
      background: #f9f9f9;
    }

    .compare-product-info {
      background: white;
      padding: 20px;
      border-radius: 0;
      margin-bottom: 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .compare-info-label {
      font-size: 10px;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
      font-weight: 400;
    }

    .compare-info-value {
      font-size: 13px;
      color: #000;
      margin-bottom: 20px;
      line-height: 1.5;
      font-weight: 300;
    }

    .compare-info-value:last-child {
      margin-bottom: 0;
    }

    .compare-add-column {
      min-width: 300px;
      max-width: 300px;
      height: calc(100vh - 60px);
      background: #fafafa;
      border: 1px solid #e8e8e8;
      border-radius: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .compare-add-column:hover {
      background: #f5f5f5;
    }

    .compare-add-content {
      text-align: center;
      color: #999;
    }

    .compare-add-icon {
      font-size: 32px;
      margin-bottom: 12px;
      color: #ccc;
    }

    .compare-add-text {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 400;
    }

    .compare-remove-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 24px;
      height: 24px;
      border-radius: 0;
      background: transparent;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      color: #999;
      transition: all 0.2s;
      z-index: 11;
    }

    .compare-remove-btn:hover {
      color: #000;
    }

    /* Product Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 300;
      align-items: center;
      justify-content: center;
    }
    .modal-overlay.active {
      display: flex;
    }
    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 30px;
      width: 50vw;
      max-width: none;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .modal-title {
      font-size: 24px;
      font-family: "MaharamNeue-Medium", sans-serif;
    }
    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 5px 10px;
      color: #666;
    }
    .modal-close:hover {
      color: #000;
    }
    .product-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
    }
    .product-card {
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 10px;
      transition: all 0.2s;
    }
    .product-card:hover {
      border-color: #007aff;
      background: #f5f5f5;
    }
    .product-card img {
      width: 100%;
      height: 180px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 10px;
    }
    .product-card-title {
      font-size: 14px;
      font-family: "MaharamNeue-Medium", sans-serif;
      margin-bottom: 4px;
    }
    .product-card-info {
      font-size: 12px;
      color: #666;
    }
    .modal-filters {
      display: flex;
      gap: 15px;
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e0e0e0;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .filter-label {
      font-size: 12px;
      font-family: "MaharamNeue-Medium", sans-serif;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .filter-select {
      padding: 8px 12px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      font-family: "MaharamNeue-Regular", sans-serif;
      font-size: 14px;
      background: white;
      cursor: pointer;
      min-width: 150px;
    }
    .filter-select:focus {
      outline: none;
      border-color: #007aff;
    }
    .modal-search {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e0e0e0;
    }
    .search-input {
      flex: 2;
      padding: 10px 15px;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      font-family: "MaharamNeue-Regular", sans-serif;
      font-size: 14px;
    }
    .search-input:focus {
      outline: none;
      border-color: #007aff;
    }
  </style>
</head>
<body>
  <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>
  
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">Workspace</div>
    <div class="sidebar-content">
      <div class="sidebar-section">
        <div class="sidebar-section-title" onclick="toggleProjectsSection()" style="cursor: pointer;">
          <span id="projectsSectionIcon">üìÇ</span> Projects
        </div>
        <div id="projectsSectionContent" style="display: block;">
          <div id="projectsList"></div>
          <div class="sidebar-item" onclick="createNewProject()" style="background: #f5f5f5; margin-top: 8px;">‚ûï New Project</div>
        </div>
      </div>
      
      <div class="sidebar-section">
        <a href="favorites.html"><div class="sidebar-section-title">Favorites</div></a>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-section-title active">Compare</div>
      </div>
      <div class="sidebar-section">
         <a href="palettes.html"><div class="sidebar-section-title">Palettes</div></a>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-section-title">Samples</div>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Color Search</div>
        <input type="color" id="colorPicker" class="sidebar-item" style="width: 100%; height: 80px; border: none; border-radius: 4px; cursor: pointer;">
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Actions</div>
        <div class="sidebar-item" onclick="clearComparison()">üóëÔ∏è Clear All</div>
        <div class="sidebar-item" onclick="exportComparison()">üíæ Export</div>
      </div>
    </div>
  </div>

  <div class="compare-container">
    <div class="compare-scroll-wrapper" id="compareWrapper">
      <!-- Columns will be added here dynamically -->
    </div>
  </div>
  
  <div class="toolbar" style="display: none;">
    <button class="tool-btn active" data-tool="select"><img src="./img/icons/SVG/Asset 1.svg" alt="Select" class="toolbar-icon"> Select</button>
    <button class="tool-btn" data-tool="product"><img src="./img/icons/SVG/Asset 3.svg" alt="Select" class="toolbar-icon"> Add Product</button>
    <button class="tool-btn" data-tool="text"><img src="./img/icons/SVG/Asset 5.svg" alt="Select" class="toolbar-icon"> Sort</button>
  </div>

  <div class="controls" style="display: none;">
    <button class="control-btn" id="zoomIn" style="display: none;">+</button>
    <button class="control-btn" id="zoomOut" style="display: none;">‚àí</button>
    <button class="control-btn" id="resetView" style="display: none;">‚åÇ</button>
    <button class="control-btn" id="deleteItem" title="Delete selected item">üóëÔ∏è</button>
  </div>

  <div class="modal-overlay" id="productModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Select a Product</div>
        <button class="modal-close" onclick="closeProductModal()">‚úï</button>
      </div>
      <div class="modal-search">
        <input type="search" class="search-input" id="productSearch" placeholder="Search products..." oninput="applyFilters()">
      </div>
      <div class="modal-filters">
        <div class="filter-group">
          <label class="filter-label">Brand</label>
          <select class="filter-select" id="filterBrand" onchange="applyFilters()">
            <option value="all">All Brands</option>
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label">Category</label>
          <select class="filter-select" id="filterCategory" onchange="applyFilters()">
            <option value="all">All Categories</option>
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label">Color</label>
          <select class="filter-select" id="filterColor" onchange="applyFilters()">
            <option value="all">All Colors</option>
          </select>
        </div>
      </div>
      <div class="product-grid" id="productGrid"></div>
    </div>
  </div>

  <script>
    // Product data (will be loaded from JSON)
    let productsData = [];
    let allProductsData = [];

    // Load product data from JSON
    async function loadProductData() {
      try {
        const response = await fetch('data/products.json');
        productsData = await response.json();
        console.log('Loaded', productsData.length, 'products');
        initializeSampleColumns();
      } catch (error) {
        console.error('Error loading product data:', error);
      }
    }

    let compareColumns = [];

    function generateId() {
      return Date.now() + Math.random().toString(36).substr(2, 9);
    }

    function createColumn(product) {
      const column = document.createElement('div');
      column.className = 'compare-column';
      column.dataset.id = product.id;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'compare-remove-btn';
      removeBtn.innerHTML = '‚úï';
      removeBtn.onclick = () => removeColumn(product.id);

      const header = document.createElement('div');
      header.className = 'compare-column-header';
      header.innerHTML = `
        <div class="compare-column-title">${product.title}</div>
        <div class="compare-column-subtitle">${product.brand}</div>
      `;

      const content = document.createElement('div');
      content.className = 'compare-column-content';
      content.innerHTML = `
        <img src="${product.imagePath}" alt="${product.title}" class="compare-product-image">
        
        <div class="compare-product-info">
          <div class="compare-info-label">Color</div>
          <div class="compare-info-value">${product.colorCode}</div>
          
          <div class="compare-info-label">Category</div>
          <div class="compare-info-value">${product.productCategory}</div>
          
          <div class="compare-info-label">Content</div>
          <div class="compare-info-value">${product.content}</div>
          
          <div class="compare-info-label">Price</div>
          <div class="compare-info-value">${product.price}</div>
        </div>
      `;

      column.appendChild(removeBtn);
      column.appendChild(header);
      column.appendChild(content);

      return column;
    }

    function createAddColumn() {
      const addColumn = document.createElement('div');
      addColumn.className = 'compare-add-column';
      addColumn.innerHTML = `
        <div class="compare-add-content">
          <div class="compare-add-icon">+</div>
          <div class="compare-add-text">Add Product to Compare</div>
        </div>
      `;
      addColumn.onclick = addColumn_click;
      return addColumn;
    }

    function addColumn_click() {
      openProductModal();
    }

    function removeColumn(id) {
      compareColumns = compareColumns.filter(col => col.id !== id);
      renderColumns();
    }

    function renderColumns() {
      const wrapper = document.getElementById('compareWrapper');
      wrapper.innerHTML = '';

      compareColumns.forEach(product => {
        wrapper.appendChild(createColumn(product));
      });

      wrapper.appendChild(createAddColumn());
    }

    function clearComparison() {
      if (confirm('Clear all products from comparison?')) {
        compareColumns = [];
        renderColumns();
      }
    }

    function exportComparison() {
      alert('Export functionality would be implemented here');
    }

    // Sidebar functionality
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebarToggle');
    let sidebarOpen = false;

    sidebarToggle.addEventListener('click', () => {
      sidebarOpen = !sidebarOpen;
      sidebar.classList.toggle('open');
      sidebarToggle.classList.toggle('open');
      sidebarToggle.textContent = sidebarOpen ? '‚úï' : '‚ò∞';
    });

    // Projects/Folders system (minimal for sidebar compatibility)
    let projectsSectionExpanded = true;
    
    function toggleProjectsSection() {
      projectsSectionExpanded = !projectsSectionExpanded;
      const content = document.getElementById('projectsSectionContent');
      const icon = document.getElementById('projectsSectionIcon');
      
      if (projectsSectionExpanded) {
        content.style.display = 'block';
        icon.textContent = 'üìÇ';
      } else {
        content.style.display = 'none';
        icon.textContent = 'üìÅ';
      }
    }

    function createNewProject() {
      alert('Project functionality not available on Compare page');
    }

    // Initialize with 3 sample columns after loading data
    function initializeSampleColumns() {
      if (productsData.length === 0) return;
      
      for (let i = 0; i < 3 && i < productsData.length; i++) {
        compareColumns.push(productsData[i]);
      }
      renderColumns();
    }

    // Product Modal functionality
    function openProductModal() {
      const modal = document.getElementById('productModal');
      
      // Build product data array
      allProductsData = productsData.map(product => ({
        imagePath: product.imagePath,
        productName: product.title,
        brand: product.brand,
        colorCode: product.colorCode,
        category: product.productCategory
      }));
      
      // Populate filter dropdowns
      populateFilters();
      
      // Display all products
      renderProducts(allProductsData);
      
      modal.classList.add('active');
    }
    
    function populateFilters() {
      // Get unique values
      const brands = [...new Set(allProductsData.map(p => p.brand))].sort();
      const categories = [...new Set(allProductsData.map(p => p.category))].sort();
      const colors = [...new Set(allProductsData.map(p => p.colorCode))].filter(c => c).sort();
      
      // Populate brand filter
      const brandSelect = document.getElementById('filterBrand');
      brandSelect.innerHTML = '<option value="all">All Brands</option>';
      brands.forEach(brand => {
        const option = document.createElement('option');
        option.value = brand;
        option.textContent = brand;
        brandSelect.appendChild(option);
      });
      
      // Populate category filter
      const categorySelect = document.getElementById('filterCategory');
      categorySelect.innerHTML = '<option value="all">All Categories</option>';
      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
      });
      
      // Populate color filter
      const colorSelect = document.getElementById('filterColor');
      colorSelect.innerHTML = '<option value="all">All Colors</option>';
      colors.forEach(color => {
        const option = document.createElement('option');
        option.value = color;
        option.textContent = color;
        colorSelect.appendChild(option);
      });
    }
    
    function applyFilters() {
      const brandFilter = document.getElementById('filterBrand').value;
      const categoryFilter = document.getElementById('filterCategory').value;
      const colorFilter = document.getElementById('filterColor').value;
      const searchQuery = document.getElementById('productSearch').value.toLowerCase();
      
      let filtered = allProductsData;
      
      if (brandFilter !== 'all') {
        filtered = filtered.filter(p => p.brand === brandFilter);
      }
      
      if (categoryFilter !== 'all') {
        filtered = filtered.filter(p => p.category === categoryFilter);
      }
      
      if (colorFilter !== 'all') {
        filtered = filtered.filter(p => p.colorCode === colorFilter);
      }
      
      if (searchQuery) {
        filtered = filtered.filter(p => 
          p.productName.toLowerCase().includes(searchQuery) ||
          p.brand.toLowerCase().includes(searchQuery) ||
          p.colorCode.toLowerCase().includes(searchQuery)
        );
      }
      
      renderProducts(filtered);
    }
    
    function renderProducts(products) {
      const productGrid = document.getElementById('productGrid');
      productGrid.innerHTML = '';
      
      products.forEach(product => {
        const card = document.createElement('div');
        card.className = 'product-card';
        card.onclick = () => selectProduct(product.imagePath);
        
        card.innerHTML = `
          <img src="${product.imagePath}" alt="${product.productName}">
          <div class="product-card-title">${product.productName}</div>
          <div class="product-card-info">${product.brand} - ${product.colorCode}</div>
        `;
        
        productGrid.appendChild(card);
      });
    }
    
    function closeProductModal() {
      const modal = document.getElementById('productModal');
      modal.classList.remove('active');
    }
    
    function selectProduct(imagePath) {
      closeProductModal();
      
      const productData = productsData.find(p => p.imagePath === imagePath);
      if (!productData) return;
      
      compareColumns.push(productData);
      renderColumns();
    }
    
    // Close modal when clicking outside
    document.getElementById('productModal').addEventListener('click', (e) => {
      if (e.target.id === 'productModal') {
        closeProductModal();
      }
    });

    // Load product data and initialize
    loadProductData();
  </script>
</body>
</html>
    const ctx = canvas.getContext('2d');

    // Canvas state
    let viewportX = 0;
    let viewportY = 0;
    let zoom = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let currentTool = 'select';
    let selectedItem = null;
    let draggedItem = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let isResizing = false;
    let resizeHandle = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;

    // Items on the canvas
    const items = [];

    // Product images available
    const productImages = [
      'img/details/KT_Beacon_901925-005_detail.jpg',
      'img/details/KT_Cozy_Cord_466938-002_detail.jpg',
      'img/details/KT_Delite_466730-018_detail.jpg',
      'img/details/KT_Facet_466804-012_detail.jpg',
      'img/details/KT_Infinite_466734-019_detail.jpg',
      'img/details/KT_Ponder_901936-002_detail.jpg',
      'img/details/KT_Vast_466945-009_detail.jpg',
      'img/details/KT_Villa_901900-005_detail.jpg',
      'img/details/KT_Wrap_Up_901937-003_detail.jpg',
      'img/details/MHRM_Cadence_466667-019_detail.jpg',
      'img/details/MHRM_Connect_466638-009_detail.jpg',
      'img/details/Maharam_Metaphor_466553_010_detail.jpg',
      'img/details/Maharam_Method_466579_021_detail.jpg',
      'img/details/Maharam_Muse_466487_026_detail.jpg',
      'img/details/Maharam_Transmit_901895_013_detail.jpg'
    ];

    // Create grid of product images
    function initializeProductGrid() {
      const rect = canvas.getBoundingClientRect();
      const gridColumns = 5;
      const cardWidth = 250;
      const cardHeight = 250;
      const gap = 30;
      
      // Calculate grid dimensions
      const gridRows = Math.ceil(productImages.length / gridColumns);
      const totalGridWidth = gridColumns * cardWidth + (gridColumns - 1) * gap;
      const totalGridHeight = gridRows * cardHeight + (gridRows - 1) * gap;
      
      // Center the grid
      const startX = (rect.width - totalGridWidth) / 2;
      const startY = (rect.height - totalGridHeight) / 2;
      
      productImages.forEach((imagePath, index) => {
        const col = index % gridColumns;
        const row = Math.floor(index / gridColumns);
        
        const fileName = imagePath.split('/').pop();
        const parts = fileName.replace('_detail.jpg', '').split('_');
        const brandCode = parts[0];
        const productName = parts[1] || 'Product';
        const colorCode = parts[2] || '';
        const brand = brandCode === 'KT' ? 'Knoll Textiles' : 
                     brandCode === 'MHRM' ? 'Maharam' : 
                     'Maharam';
        
        items.push({
          type: 'product',
          x: startX + col * (cardWidth + gap),
          y: startY + row * (cardHeight + gap),
          width: cardWidth,
          height: cardHeight,
          imagePath: imagePath,
          title: productName,
          brand: brand,
          color: colorCode,
          productCategory: 'Upholstery',
          content: 'Textile',
          price: '$85.00 / yd',
          flipped: false,
          id: generateId()
        });
      });
    }
    
    initializeProductGrid();

    function generateId() {
      return Date.now() + Math.random().toString(36).substr(2, 9);
    }

    // Setup canvas
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      
      ctx.scale(dpr, dpr);
      
      draw();
    }

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Drawing functions
    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      
      ctx.save();
      ctx.translate(viewportX, viewportY);
      ctx.scale(zoom, zoom);
      
      drawGrid();
      drawItems();
      
      ctx.restore();
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const gridSize = 40;
      const dotSize = 1.5;
      
      // Calculate visible area in world coordinates
      const startX = Math.floor((-viewportX / zoom) / gridSize) * gridSize;
      const startY = Math.floor((-viewportY / zoom) / gridSize) * gridSize;
      const endX = Math.ceil((rect.width - viewportX) / zoom / gridSize) * gridSize;
      const endY = Math.ceil((rect.height - viewportY) / zoom / gridSize) * gridSize;
      
      // Draw dots
      ctx.fillStyle = '#d0d0d0';
      for (let x = startX; x <= endX; x += gridSize) {
        for (let y = startY; y <= endY; y += gridSize) {
          ctx.beginPath();
          ctx.arc(x, y, dotSize / zoom, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw major grid lines (every 5 grid units)
      ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.lineWidth = 1 / zoom;
      
      ctx.beginPath();
      for (let x = startX; x <= endX; x += gridSize * 5) {
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
      }
      for (let y = startY; y <= endY; y += gridSize * 5) {
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
      }
      ctx.stroke();
    }

    function drawItems() {
      items.forEach(item => {
        if (item.type === 'product') {
          drawProduct(item);
        } else if (item.type === 'text') {
          drawText(item);
        }
        
        // Highlight selected item
        if (selectedItem === item) {
          ctx.strokeStyle = '#007aff';
          ctx.lineWidth = 3 / zoom;
          ctx.strokeRect(item.x - 5, item.y - 5, item.width + 10, item.height + 10);
          
          // Resize disabled for favorites
          /*
          // Draw resize handles for products
          if (item.type === 'product') {
            drawResizeHandles(item);
          }
          */
        }
      });
    }

    function drawResizeHandles(item) {
      const handleSize = 10 / zoom;
      const handles = [
        { x: item.x - 5, y: item.y - 5 },
        { x: item.x + item.width - handleSize + 5, y: item.y - 5 },
        { x: item.x - 5, y: item.y + item.height - handleSize + 5 },
        { x: item.x + item.width - handleSize + 5, y: item.y + item.height - handleSize + 5 }
      ];
      
      ctx.fillStyle = '#007aff';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2 / zoom;
      
      handles.forEach(handle => {
        ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
        ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
      });
    }

    function drawProduct(item) {
      const cornerRadius = 2;
      
      // Shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
      ctx.shadowBlur = 15 / zoom;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 6 / zoom;
      
      // White background card
      ctx.fillStyle = '#ffffff';
      roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
      ctx.fill();
      
      ctx.restore();
      
      // Border
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.lineWidth = 1 / zoom;
      roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
      ctx.stroke();
      
      if (item.flipped) {
        // Show text information on back of card
        ctx.fillStyle = '#f8f8f8';
        roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
        ctx.fill();
        
        ctx.textAlign = 'center';
        
        const centerX = item.x + item.width / 2;
        let yOffset = item.y + 30;
        const lineHeight = 20 / zoom;
        
        // Title
        if (item.title) {
          ctx.font = `${18 / zoom}px "MaharamNeue-Medium", sans-serif`;
          ctx.textAlign = 'center';
          ctx.fillStyle = '#333';
          ctx.fillText(item.title, centerX, yOffset);
          yOffset += lineHeight + 5 / zoom;
        }
        
        // Brand
        if (item.brand) {
          ctx.font = `${18 / zoom}px "MaharamNeue-Medium", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.brand, centerX, yOffset);
          yOffset += lineHeight;
        }
        
        // Color
        if (item.color) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.color, centerX, yOffset);
          yOffset += lineHeight + 10 / zoom;
        }
        
        // Product Category
        if (item.productCategory) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.productCategory, centerX, yOffset);
          yOffset += lineHeight;
        }
        
        // Content
        if (item.content) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.content, centerX, yOffset);
          yOffset += lineHeight + 10 / zoom;
        }
        
        // Price
        if (item.price) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.price, centerX, yOffset);
        }
        
        ctx.textAlign = 'left';
      } else {
        // Show image on front of card
        // Load and draw image
        if (!item.imageElement) {
          item.imageElement = new Image();
          item.imageElement.src = item.imagePath;
          item.imageElement.onload = () => draw();
        }
        
        if (item.imageElement.complete) {
          const padding = 5;
          const imgWidth = item.width - padding * 2;
          const imgHeight = item.height - padding * 2;
          
          ctx.save();
          // Clip to rounded rect for image
          ctx.beginPath();
          roundRect(ctx, item.x + padding, item.y + padding, imgWidth, imgHeight, cornerRadius - 2);
          ctx.clip();
          ctx.drawImage(item.imageElement, item.x + padding, item.y + padding, imgWidth, imgHeight);
          ctx.restore();
        }
        
        // Product name and color at bottom
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `${11 / zoom}px "MaharamNeue-Regular", sans-serif`;
        ctx.textAlign = 'center';
        const bottomText = `${item.title || 'Product'}${item.color ? ' - ' + item.color : ''}`;
        ctx.fillText(bottomText, item.x + item.width / 2, item.y + item.height - 15);
        ctx.textAlign = 'left';
      }
    }

    function drawText(item) {
      ctx.fillStyle = '#000';
      ctx.font = `${18 / zoom}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
      wrapText(ctx, item.text, item.x, item.y, item.width, 26 / zoom);
    }

    function roundRect(ctx, x, y, width, height, radius) {
      radius = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let currentY = y;
      
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && i > 0) {
          ctx.fillText(line, x, currentY);
          line = words[i] + ' ';
          currentY += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, currentY);
    }

    // Coordinate conversion
    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - viewportX) / zoom,
        y: (screenY - viewportY) / zoom
      };
    }

    function worldToScreen(worldX, worldY) {
      return {
        x: worldX * zoom + viewportX,
        y: worldY * zoom + viewportY
      };
    }

    // Hit detection
    function getItemAtPosition(worldX, worldY) {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (worldX >= item.x && worldX <= item.x + item.width &&
            worldY >= item.y && worldY <= item.y + item.height) {
          return item;
        }
      }
      return null;
    }

    function getResizeHandle(item, worldX, worldY) {
      if (!item || item.type !== 'product') return null;
      
      const handleSize = 10 / zoom;
      const threshold = 5 / zoom;
      
      const handles = [
        { name: 'nw', x: item.x - 5, y: item.y - 5 },
        { name: 'ne', x: item.x + item.width - handleSize + 5, y: item.y - 5 },
        { name: 'sw', x: item.x - 5, y: item.y + item.height - handleSize + 5 },
        { name: 'se', x: item.x + item.width - handleSize + 5, y: item.y + item.height - handleSize + 5 }
      ];
      
      for (let handle of handles) {
        if (worldX >= handle.x - threshold && worldX <= handle.x + handleSize + threshold &&
            worldY >= handle.y - threshold && worldY <= handle.y + handleSize + threshold) {
          return handle.name;
        }
      }
      
      return null;
    }

    // Mouse events
    canvas.addEventListener('dblclick', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      const item = getItemAtPosition(world.x, world.y);
      if (item && item.type === 'product') {
        item.flipped = !item.flipped;
        draw();
      } else if (item && item.type === 'text') {
        const newText = prompt('Edit text:', item.text);
        if (newText !== null) {
          item.text = newText;
          draw();
        }
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      if (currentTool === 'select') {
        // Resize disabled
        /*
        // Check if clicking on a resize handle first
        if (selectedItem && selectedItem.type === 'product') {
          const handle = getResizeHandle(selectedItem, world.x, world.y);
          if (handle) {
            isResizing = true;
            resizeHandle = handle;
            resizeStartX = world.x;
            resizeStartY = world.y;
            resizeStartWidth = selectedItem.width;
            resizeStartHeight = selectedItem.height;
            return;
          }
        }
        */
        
        const item = getItemAtPosition(world.x, world.y);
        
        if (item) {
          selectedItem = item;
          draggedItem = item;
          dragOffsetX = world.x - item.x;
          dragOffsetY = world.y - item.y;
          
          // Move to front
          items.splice(items.indexOf(item), 1);
          items.push(item);
        } else {
          selectedItem = null;
          // Pan disabled
          // isDragging = true;
          // dragStartX = mouseX;
          // dragStartY = mouseY;
        }
      } else {
        // Check if clicking on existing text item when text tool is selected
        const item = getItemAtPosition(world.x, world.y);
        if (currentTool === 'text' && item && item.type === 'text') {
          // Edit existing text item
          const newText = prompt('Edit text:', item.text);
          if (newText !== null) {
            item.text = newText;
            selectedItem = item;
          }
          draw();
          return; // Don't add new item
        } else {
          // Add new item
          addItem(currentTool, world.x, world.y);
        }
      }
      
      draw();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      // Pan disabled
      /*
      if (isDragging) {
        const dx = mouseX - dragStartX;
        const dy = mouseY - dragStartY;
        viewportX += dx;
        viewportY += dy;
        dragStartX = mouseX;
        dragStartY = mouseY;
        draw();
      } else */
      // Resize disabled
      /*
      if (isResizing && selectedItem) {
        const dx = world.x - resizeStartX;
        const dy = world.y - resizeStartY;
        const minSize = 100;
        
        if (resizeHandle === 'se') {
          selectedItem.width = Math.max(minSize, resizeStartWidth + dx);
          selectedItem.height = Math.max(minSize, resizeStartHeight + dy);
        } else if (resizeHandle === 'sw') {
          const newWidth = Math.max(minSize, resizeStartWidth - dx);
          if (newWidth > minSize) {
            selectedItem.x = selectedItem.x + (selectedItem.width - newWidth);
          }
          selectedItem.width = newWidth;
          selectedItem.height = Math.max(minSize, resizeStartHeight + dy);
        } else if (resizeHandle === 'ne') {
          selectedItem.width = Math.max(minSize, resizeStartWidth + dx);
          const newHeight = Math.max(minSize, resizeStartHeight - dy);
          if (newHeight > minSize) {
            selectedItem.y = selectedItem.y + (selectedItem.height - newHeight);
          }
          selectedItem.height = newHeight;
        } else if (resizeHandle === 'nw') {
          const newWidth = Math.max(minSize, resizeStartWidth - dx);
          const newHeight = Math.max(minSize, resizeStartHeight - dy);
          if (newWidth > minSize) {
            selectedItem.x = selectedItem.x + (selectedItem.width - newWidth);
          }
          if (newHeight > minSize) {
            selectedItem.y = selectedItem.y + (selectedItem.height - newHeight);
          }
          selectedItem.width = newWidth;
          selectedItem.height = newHeight;
        }
        
        draw();
      } else */
      if (draggedItem) {
        draggedItem.x = world.x - dragOffsetX;
        draggedItem.y = world.y - dragOffsetY;
        draw();
      } else {
        // Update cursor based on hover
        // Resize disabled
        /*
        if (selectedItem && selectedItem.type === 'product') {
          const handle = getResizeHandle(selectedItem, world.x, world.y);
          if (handle) {
            canvas.style.cursor = handle + '-resize';
            return;
          }
        }
        */
        const item = getItemAtPosition(world.x, world.y);
        canvas.style.cursor = item ? 'move' : 'grab';
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      draggedItem = null;
      isResizing = false;
      resizeHandle = null;
      canvas.style.cursor = 'grab';
    });

    // Zoom
    // Zoom disabled
    /*
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const worldBeforeZoom = screenToWorld(mouseX, mouseY);
      
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      zoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
      
      const worldAfterZoom = screenToWorld(mouseX, mouseY);
      
      viewportX += (worldAfterZoom.x - worldBeforeZoom.x) * zoom;
      viewportY += (worldAfterZoom.y - worldBeforeZoom.y) * zoom;
      
      draw();
    }, { passive: false });
    */

    // Tool selection
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
      });
    });

    // Controls
    /*
    document.getElementById('zoomIn').addEventListener('click', () => {
      zoom = Math.min(5, zoom * 1.2);
      draw();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      zoom = Math.max(0.1, zoom / 1.2);
      draw();
    });
    */

    document.getElementById('resetView').addEventListener('click', () => {
      viewportX = 0;
      viewportY = 0;
      zoom = 1;
      draw();
    });

    document.getElementById('deleteItem').addEventListener('click', () => {
      deleteSelectedItem();
    });

    // Delete selected item function
    function deleteSelectedItem() {
      if (selectedItem) {
        const index = items.indexOf(selectedItem);
        if (index > -1) {
          items.splice(index, 1);
          selectedItem = null;
          updateProjectsList();
          draw();
        }
      }
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      // Delete or Backspace key
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItem) {
        e.preventDefault();
        deleteSelectedItem();
      }
    });

    // Add new items
    function addItem(type, x, y) {
      const colors = ['#FFE680', '#FF9E9E', '#A0D8FF', '#B4E7CE', '#E7B4E7', '#FFD4A3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      
      let newItem;
      
      if (type === 'product') {
        const randomImage = productImages[Math.floor(Math.random() * productImages.length)];
        const fileName = randomImage.split('/').pop();
        const parts = fileName.replace('_detail.jpg', '').split('_');
        
        // Extract brand, title, and color from filename
        // Format: BRAND_Title_ColorCode_detail.jpg
        const brandCode = parts[0];
        const productName = parts[1] || 'Product';
        const colorCode = parts[2] || '';
        
        const brand = brandCode === 'KT' ? 'Knoll Textiles' : 
                     brandCode === 'MHRM' ? 'Maharam' : 
                     'Maharam';
        
        newItem = {
          type: 'product',
          x: x - 125,
          y: y - 125,
          width: 250,
          height: 250,
          imagePath: randomImage,
          title: productName,
          brand: brand,
          color: colorCode,
          productCategory: 'Upholstery',
          content: 'Textile',
          price: '$85.00 / yd',
          flipped: false,
          id: generateId()
        };
      } else if (type === 'text') {
        const textContent = prompt('Enter text:', 'Click to edit text');
        if (textContent === null) {
          return; // User cancelled
        }
        newItem = {
          type: 'text',
          x: x,
          y: y,
          width: 300,
          height: 80,
          text: textContent,
          id: generateId()
        };
      }
      
      if (newItem) {
        items.push(newItem);
        selectedItem = newItem;
        draw();
      }
    }

    // Sidebar functionality
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebarToggle');
    let sidebarOpen = false;

    sidebarToggle.addEventListener('click', () => {
      sidebarOpen = !sidebarOpen;
      sidebar.classList.toggle('open');
      sidebarToggle.classList.toggle('open');
      sidebarToggle.textContent = sidebarOpen ? '‚úï' : '‚ò∞';
    });

    // Projects/Folders system
    let projectsSectionExpanded = true;
    
    const projects = [
      { id: 'default', name: 'My Project', expanded: true, items: [] },
      { id: 'ideas', name: 'Ideas', expanded: false, items: [] }
    ];
    
    function toggleProjectsSection() {
      projectsSectionExpanded = !projectsSectionExpanded;
      const content = document.getElementById('projectsSectionContent');
      const icon = document.getElementById('projectsSectionIcon');
      
      if (projectsSectionExpanded) {
        content.style.display = 'block';
        icon.textContent = 'üìÇ';
      } else {
        content.style.display = 'none';
        icon.textContent = 'üìÅ';
      }
    }

    // Assign initial items to default project
    items.forEach(item => {
      if (!item.projectId) {
        item.projectId = 'default';
      }
    });

    function createNewProject() {
      const projectName = prompt('Enter project name:', 'New Project');
      if (projectName) {
        const newProject = {
          id: generateId(),
          name: projectName,
          expanded: true,
          items: []
        };
        projects.push(newProject);
        updateProjectsList();
      }
    }

    function deleteProject(projectId) {
      if (confirm('Delete this project and all its items?')) {
        const projectIndex = projects.findIndex(p => p.id === projectId);
        if (projectIndex > -1) {
          // Remove all items in this project
          for (let i = items.length - 1; i >= 0; i--) {
            if (items[i].projectId === projectId) {
              items.splice(i, 1);
            }
          }
          projects.splice(projectIndex, 1);
          selectedItem = null;
          updateProjectsList();
          draw();
        }
      }
    }

    function renameProject(projectId) {
      const project = projects.find(p => p.id === projectId);
      if (project) {
        const newName = prompt('Enter new project name:', project.name);
        if (newName) {
          project.name = newName;
          updateProjectsList();
        }
      }
    }

    function toggleProject(projectId) {
      const project = projects.find(p => p.id === projectId);
      if (project) {
        project.expanded = !project.expanded;
        updateProjectsList();
      }
    }

    // Update projects list
    function updateProjectsList() {
      const projectsList = document.getElementById('projectsList');
      projectsList.innerHTML = '';
      
      projects.forEach(project => {
        const projectFolder = document.createElement('div');
        projectFolder.className = 'project-folder';
        
        const projectHeader = document.createElement('div');
        projectHeader.className = 'project-header';
        
        const projectTitle = document.createElement('div');
        projectTitle.className = 'project-title';
        
        const projectItems = items.filter(item => item.projectId === project.id);
        const expandIcon = project.expanded ? 'üìÇ' : 'üìÅ';
        
        projectTitle.innerHTML = `${expandIcon} ${project.name} (${projectItems.length})`;
        projectTitle.onclick = () => toggleProject(project.id);
        
        const projectActions = document.createElement('div');
        projectActions.className = 'project-actions';
        
        const renameBtn = document.createElement('button');
        renameBtn.className = 'project-action-btn';
        renameBtn.innerHTML = '‚úèÔ∏è';
        renameBtn.title = 'Rename';
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          renameProject(project.id);
        };
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'project-action-btn';
        deleteBtn.innerHTML = 'üóëÔ∏è';
        deleteBtn.title = 'Delete';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteProject(project.id);
        };
        
        projectActions.appendChild(renameBtn);
        projectActions.appendChild(deleteBtn);
        
        projectHeader.appendChild(projectTitle);
        projectHeader.appendChild(projectActions);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'project-items';
        if (project.expanded) {
          itemsContainer.classList.add('expanded');
        }
        
        projectItems.forEach(item => {
          const projectItem = document.createElement('div');
          projectItem.className = 'project-item';
          if (selectedItem === item) {
            projectItem.classList.add('selected');
          }
          
          const icon = item.type === 'product' ? 'üñºÔ∏è' : 'üìÑ';
          const text = item.type === 'product' ? (item.title || 'Product') : 
                       item.text.substring(0, 20);
          
          projectItem.innerHTML = `${icon} ${text}${text.length >= 20 ? '...' : ''}`;
          projectItem.onclick = () => {
            selectedItem = item;
            updateProjectsList();
            draw();
          };
          
          // Add context menu for moving items
          projectItem.oncontextmenu = (e) => {
            e.preventDefault();
            showItemContextMenu(e, item);
          };
          
          itemsContainer.appendChild(projectItem);
        });
        
        projectFolder.appendChild(projectHeader);
        projectFolder.appendChild(itemsContainer);
        projectsList.appendChild(projectFolder);
      });
    }

    function showItemContextMenu(e, item) {
      const moveToMenu = prompt('Move to project (enter project name):\n' + 
        projects.map(p => `- ${p.name}`).join('\n'));
      
      if (moveToMenu) {
        const targetProject = projects.find(p => 
          p.name.toLowerCase() === moveToMenu.toLowerCase()
        );
        if (targetProject) {
          item.projectId = targetProject.id;
          updateProjectsList();
        }
      }
    }

    // Setup color palette
    function setupColorPalette() {
      const colors = ['#FFE680', '#FF9E9E', '#A0D8FF', '#B4E7CE', '#E7B4E7', '#FFD4A3'];
      const colorPalette = document.getElementById('colorPalette');
      
      colors.forEach(color => {
        const swatch = document.createElement('div');
        swatch.className = 'sidebar-item';
        swatch.style.padding = '0';
        swatch.style.height = '40px';
        swatch.style.display = 'flex';
        swatch.style.alignItems = 'center';
        swatch.style.justifyContent = 'center';
        
        const colorDiv = document.createElement('div');
        colorDiv.className = 'color-swatch';
        colorDiv.style.backgroundColor = color;
        colorDiv.style.width = '100%';
        colorDiv.style.height = '100%';
        colorDiv.style.borderRadius = '6px';
        
        swatch.appendChild(colorDiv);
        
        colorPalette.appendChild(swatch);
      });
    }

    // Clean up grid - arrange products in a grid layout with animation
    function cleanUpGrid() {
      const products = items.filter(item => item.type === 'product');
      if (products.length === 0) return;
      
      const gridSpacing = 30;
      const startX = 100;
      const startY = 100;
      
      // Find the most common width to use as standard
      const widths = products.map(p => p.width);
      const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;
      const avgHeight = products.reduce((sum, p) => sum + p.height, 0) / products.length;
      
      // Calculate columns based on canvas width
      const canvasWidth = canvas.getBoundingClientRect().width / zoom;
      const itemWidthWithSpacing = avgWidth + gridSpacing;
      const columns = Math.floor((canvasWidth - startX * 2) / itemWidthWithSpacing) || 3;
      
      // Store start and end positions for animation
      const animations = products.map((product, index) => {
        const col = index % columns;
        const row = Math.floor(index / columns);
        
        return {
          product: product,
          startX: product.x,
          startY: product.y,
          endX: startX + col * (avgWidth + gridSpacing),
          endY: startY + row * (avgHeight + gridSpacing)
        };
      });
      
      // Animate to grid positions
      const duration = 500; // milliseconds
      const startTime = performance.now();
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function (ease-out cubic)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        animations.forEach(anim => {
          anim.product.x = anim.startX + (anim.endX - anim.startX) * easeProgress;
          anim.product.y = anim.startY + (anim.endY - anim.startY) * easeProgress;
        });
        
        draw();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          updateProjectsList();
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Sort grid (reverse order with animation)
    function sortGrid() {
      const products = items.filter(item => item.type === 'product');
      if (products.length === 0) {
        console.log('No products to sort');
        return;
      }
      
      console.log('Sorting', products.length, 'products');
      
      // Get grid layout parameters (match initializeProductGrid)
      const rect = canvas.getBoundingClientRect();
      const gridColumns = 5;
      const cardWidth = 250;
      const cardHeight = 250;
      const gap = 30;
      
      const gridRows = Math.ceil(products.length / gridColumns);
      const totalGridWidth = gridColumns * cardWidth + (gridColumns - 1) * gap;
      const totalGridHeight = gridRows * cardHeight + (gridRows - 1) * gap;
      
      const startX = (rect.width - totalGridWidth) / 2;
      const startY = (rect.height - totalGridHeight) / 2;
      
      // Store current positions and calculate target positions for reverse order
      const animations = [];
      
      for (let i = 0; i < products.length; i++) {
        const product = products[i];
        const reversedIndex = products.length - 1 - i;
        
        const targetCol = reversedIndex % gridColumns;
        const targetRow = Math.floor(reversedIndex / gridColumns);
        
        animations.push({
          product: product,
          startX: product.x,
          startY: product.y,
          endX: startX + targetCol * (cardWidth + gap),
          endY: startY + targetRow * (cardHeight + gap)
        });
      }
      
      console.log('Starting animation with', animations.length, 'items');
      
      // Animate to new positions
      const duration = 800;
      const startTime = performance.now();
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function (ease-in-out cubic)
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;
        
        // Update positions
        for (let i = 0; i < animations.length; i++) {
          const anim = animations[i];
          anim.product.x = anim.startX + (anim.endX - anim.startX) * easeProgress;
          anim.product.y = anim.startY + (anim.endY - anim.startY) * easeProgress;
        }
        
        draw();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          console.log('Animation complete - reversing items array');
          
          // After animation, reverse the actual order in the items array
          const reversedProducts = products.reverse();
          
          // Remove all products from items
          for (let i = items.length - 1; i >= 0; i--) {
            if (items[i].type === 'product') {
              items.splice(i, 1);
            }
          }
          
          // Add reversed products back
          items.unshift(...reversedProducts);
          
          console.log('Items array updated');
          draw();
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Clear canvas
    function clearCanvas() {
      if (confirm('Are you sure you want to clear the canvas?')) {
        items.length = 0;
        selectedItem = null;
        updateProjectsList();
        draw();
      }
    }

    // Export canvas
    function exportCanvas() {
      const link = document.createElement('a');
      link.download = 'canvas-export.png';
      link.href = canvas.toDataURL();
      link.click();
    }

    // Initialize sidebar
    // setupColorPalette();
    updateProjectsList();

    // Update projects list when items change
    const originalAddItem = addItem;
    addItem = function(type, x, y) {
      originalAddItem(type, x, y);
      // Assign to first project by default
      if (items.length > 0 && !items[items.length - 1].projectId) {
        items[items.length - 1].projectId = projects[0].id;
      }
      updateProjectsList();
    };

    // Initial draw
    draw();
  </script>
</body>
</html>