<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Canvas Board</title>
    <link rel="stylesheet" href="src/styles.css">
    <style>
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 300;
        align-items: center;
        justify-content: center;
      }
      .modal-overlay.active {
        display: flex;
      }
      .modal-content {
        background: white;
        border-radius: 12px;
        padding: 30px;
        width: 50vw;
        max-width: none;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .modal-title {
        font-size: 24px;
        font-family: "MaharamNeue-Medium", sans-serif;
      }
      .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        padding: 5px 10px;
        color: #666;
      }
      .modal-close:hover {
        color: #000;
      }
      .product-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 20px;
      }
      .product-card {
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
        padding: 10px;
        transition: all 0.2s;
      }
      .product-card:hover {
        border-color: #007aff;
        background: #f5f5f5;
      }
      .product-card img {
        width: 100%;
        height: 180px;
        object-fit: cover;
        border-radius: 6px;
        margin-bottom: 10px;
      }
      .product-card-title {
        font-size: 14px;
        font-family: "MaharamNeue-Medium", sans-serif;
        margin-bottom: 4px;
      }
      .product-card-info {
        font-size: 12px;
        color: #666;
      }
      .modal-filters {
        display: flex;
        gap: 15px;
        margin-bottom: 25px;
        padding-bottom: 20px;
        border-bottom: 1px solid #e0e0e0;
      }
      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .filter-label {
        font-size: 12px;
        font-family: "MaharamNeue-Medium", sans-serif;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .filter-select {
        padding: 8px 12px;
        border: 1px solid #d0d0d0;
        border-radius: 6px;
        font-family: "MaharamNeue-Regular", sans-serif;
        font-size: 14px;
        background: white;
        cursor: pointer;
        min-width: 150px;
      }
      .filter-select:focus {
        outline: none;
        border-color: #007aff;
      }
      .modal-search {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 25px;
        padding-bottom: 20px;
        border-bottom: 1px solid #e0e0e0;
      }
      .search-input {
        flex: 2;
        padding: 10px 15px;
        border: 1px solid #d0d0d0;
        border-radius: 6px;
        font-family: "MaharamNeue-Regular", sans-serif;
        font-size: 14px;
      }
      .search-input:focus {
        outline: none;
        border-color: #007aff;
      }
      
      /* Context Menu Styles */
      .context-menu {
        position: fixed;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 8px;
        z-index: 300;
        display: none;
        min-width: 180px;
      }
      
      .context-menu.active {
        display: block;
      }
      
      .context-menu-item {
        padding: 10px 16px;
        cursor: pointer;
        border-radius: 6px;
        font-family: "MaharamNeue-Regular", sans-serif;
        font-size: 14px;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      
      .context-menu-item:hover {
        background: #f5f5f5;
      }
      
      .context-menu-icon {
        font-size: 16px;
      }
    </style>
</head>
<body>
  <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>
  
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">Workspace</div>
    <div class="sidebar-content">
      <div class="sidebar-section">
        <div class="sidebar-section-title" onclick="toggleProjectsSection()" style="cursor: pointer;">
          <span id="projectsSectionIcon">üìÇ</span> Projects
        </div>
        <div id="projectsSectionContent" style="display: block;">
          <div id="projectsList"></div>
          <div class="sidebar-item" onclick="createNewProject()" style="background: #f5f5f5; margin-top: 8px;">‚ûï New Project</div>
        </div>
      </div>
      
      <div class="sidebar-section">
        <a href="favorites.html"><div class="sidebar-section-title">Favorites</div></a>
      </div>
      <div class="sidebar-section">
        <a href="compare.html"><div class="sidebar-section-title">Compare</div></a>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-section-title active" onclick="togglePalettesSection()" style="cursor: pointer;">
          <span id="palettesSectionIcon">üìÇ</span> Palettes
        </div>
        <div id="palettesSectionContent" style="display: block;">
          <div id="palettesList"></div>
          <div class="sidebar-item" onclick="createNewPalette()" style="background: #f5f5f5; margin-top: 8px;">‚ûï New Palette</div>
        </div>
      </div>
      <div class="sidebar-section">
        <a href="samples.html"><div class="sidebar-section-title">Samples</div></a>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Color Search</div>
        <input type="color" id="colorPicker" class="sidebar-item" style="width: 100%; height: 80px; border: none; border-radius: 4px; cursor: pointer;">
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-title">Actions</div>
        <div class="sidebar-item" onclick="cleanUpGrid()">üìä Clean Up Grid</div>
        <div class="sidebar-item" onclick="clearCanvas()">üóëÔ∏è Clear Canvas</div>
        <div class="sidebar-item" onclick="exportCanvas()">üíæ Export View</div>
      </div>
    </div>
  </div>

  <canvas id="canvas"></canvas>
  
  <div class="toolbar">
    <button class="tool-btn active" data-tool="select"><img src="./img/icons/SVG/Asset 1.svg" alt="Select" class="toolbar-icon"> Select</button>
    <button class="tool-btn" data-tool="product"><img src="./img/icons/SVG/Asset 3.svg" alt="Select" class="toolbar-icon"> Product</button>
    <button class="tool-btn" data-tool="text"><img src="./img/icons/SVG/Asset 4.svg" alt="Select" class="toolbar-icon"> Text</button>
  </div>

  <div class="controls">
    <button class="control-btn" id="zoomIn">+</button>
    <button class="control-btn" id="zoomOut">‚àí</button>
    <button class="control-btn" id="resetView">‚åÇ</button>
    <button class="control-btn" id="deleteItem" title="Delete selected item">üóëÔ∏è</button>
  </div>

  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="addSampleToCart()">
      <span class="context-menu-icon">üõçÔ∏è</span>
      <span id="contextMenuCartText">Add Sample to Cart</span>
    </div>
    <div class="context-menu-item" onclick="addToCompare()">
      <span class="context-menu-icon">‚öñÔ∏è</span>
      <span id="contextMenuCompareText">Add to Compare</span>
    </div>
    <div class="context-menu-item" onclick="flipSelectedProduct()">
      <span class="context-menu-icon">üîÑ</span>
      <span id="contextMenuFlipText">Flip Card</span>
    </div>
    <div class="context-menu-item" onclick="deleteSelectedItem()">
      <span class="context-menu-icon">üóëÔ∏è</span>
      <span id="contextMenuDeleteText">Delete</span>
    </div>
  </div>

  <div class="modal-overlay" id="productModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Select a Product</div>
        <button class="modal-close" onclick="closeProductModal()">‚úï</button>
      </div>
      <div class="modal-search">
        <input type="search" class="search-input" id="productSearch" placeholder="Search products..." oninput="applyFilters()">
      </div>
      <div class="modal-filters">
        <div class="filter-group">
          <label class="filter-label">Brand</label>
          <select class="filter-select" id="filterBrand" onchange="applyFilters()">
            <option value="all">All Brands</option>
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label">Category</label>
          <select class="filter-select" id="filterCategory" onchange="applyFilters()">
            <option value="all">All Categories</option>
          </select>
        </div>
        <div class="filter-group">
          <label class="filter-label">Color</label>
          <select class="filter-select" id="filterColor" onchange="applyFilters()">
            <option value="all">All Colors</option>
          </select>
        </div>
      </div>
      <div class="product-grid" id="productGrid"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Canvas state
    let viewportX = 0;
    let viewportY = 0;
    let zoom = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let currentTool = 'select';
    let selectedItem = null;
    let selectedItems = []; // Array for multi-selection
    let draggedItem = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let isResizing = false;
    let resizeHandle = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;

    // Items on the canvas
    const items = [];

    // Product data (will be loaded from JSON)
    let productsData = [];
    
    // Load product data from JSON
    async function loadProductData() {
      try {
        const response = await fetch('data/products.json');
        productsData = await response.json();
        console.log('Loaded', productsData.length, 'products');
        initializeCanvas();
      } catch (error) {
        console.error('Error loading product data:', error);
      }
    }
    
    // Initialize canvas with sample products
    function initializeCanvas() {
      if (productsData.length < 2) return;
      
      items.push({
        type: 'product',
        x: 100,
        y: 100,
        width: 250,
        height: 250,
        imagePath: productsData[0].imagePath,
        title: productsData[0].title,
        brand: productsData[0].brand,
        color: productsData[0].colorCode,
        productCategory: productsData[0].productCategory,
        content: productsData[0].content,
        price: productsData[0].price,
        flipped: false,
        id: generateId()
      });

      items.push({
        type: 'product',
        x: 400,
        y: 100,
        width: 250,
        height: 250,
        imagePath: productsData[1].imagePath,
        title: productsData[1].title,
        brand: productsData[1].brand,
        color: productsData[1].colorCode,
        productCategory: productsData[1].productCategory,
        content: productsData[1].content,
        price: productsData[1].price,
        flipped: false,
        id: generateId()
      });

      items.push({
        type: 'text',
        x: 100,
        y: 400,
        width: 300,
        height: 80,
        text: 'Click product tool to add thumbnails',
        id: generateId()
      });
      
      draw();
    }

    function generateId() {
      return Date.now() + Math.random().toString(36).substr(2, 9);
    }

    // Setup canvas
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      
      ctx.scale(dpr, dpr);
      
      draw();
    }

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Drawing functions
    function draw() {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      
      ctx.save();
      ctx.translate(viewportX, viewportY);
      ctx.scale(zoom, zoom);
      
      drawGrid();
      drawItems();
      
      ctx.restore();
    }

    function drawGrid() {
      const rect = canvas.getBoundingClientRect();
      const gridSize = 40;
      const dotSize = 1.5;
      
      // Calculate visible area in world coordinates
      const startX = Math.floor((-viewportX / zoom) / gridSize) * gridSize;
      const startY = Math.floor((-viewportY / zoom) / gridSize) * gridSize;
      const endX = Math.ceil((rect.width - viewportX) / zoom / gridSize) * gridSize;
      const endY = Math.ceil((rect.height - viewportY) / zoom / gridSize) * gridSize;
      
      // Draw dots
      ctx.fillStyle = '#d0d0d0';
      for (let x = startX; x <= endX; x += gridSize) {
        for (let y = startY; y <= endY; y += gridSize) {
          ctx.beginPath();
          ctx.arc(x, y, dotSize / zoom, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw major grid lines (every 5 grid units)
      ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.lineWidth = 1 / zoom;
      
      ctx.beginPath();
      for (let x = startX; x <= endX; x += gridSize * 5) {
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
      }
      for (let y = startY; y <= endY; y += gridSize * 5) {
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
      }
      ctx.stroke();
    }

    function drawItems() {
      items.forEach(item => {
        if (item.type === 'product') {
          drawProduct(item);
        } else if (item.type === 'text') {
          drawText(item);
        }
        
        // Highlight selected item or items in multi-selection
        if (selectedItem === item || selectedItems.includes(item)) {
          ctx.strokeStyle = '#007aff';
          ctx.lineWidth = 3 / zoom;
          ctx.strokeRect(item.x - 5, item.y - 5, item.width + 10, item.height + 10);
          
          // Draw resize handles for products (only for single selection)
          if (item.type === 'product' && selectedItem === item && selectedItems.length === 0) {
            drawResizeHandles(item);
          }
        }
      });
    }

    function drawResizeHandles(item) {
      const handleSize = 10 / zoom;
      const handles = [
        { x: item.x - 5, y: item.y - 5 },
        { x: item.x + item.width - handleSize + 5, y: item.y - 5 },
        { x: item.x - 5, y: item.y + item.height - handleSize + 5 },
        { x: item.x + item.width - handleSize + 5, y: item.y + item.height - handleSize + 5 }
      ];
      
      ctx.fillStyle = '#007aff';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2 / zoom;
      
      handles.forEach(handle => {
        ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
        ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
      });
    }

    function drawProduct(item) {
      const cornerRadius = 2;
      
      // Shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
      ctx.shadowBlur = 15 / zoom;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 6 / zoom;
      
      // White background card
      ctx.fillStyle = '#ffffff';
      roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
      ctx.fill();
      
      ctx.restore();
      
      // Border
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.lineWidth = 1 / zoom;
      roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
      ctx.stroke();
      
      if (item.flipped) {
        // Show text information on back of card
        ctx.fillStyle = '#f8f8f8';
        roundRect(ctx, item.x, item.y, item.width, item.height, cornerRadius);
        ctx.fill();
        
        ctx.textAlign = 'center';
        
        const centerX = item.x + item.width / 2;
        let yOffset = item.y + 30;
        const lineHeight = 20 / zoom;
        
        // Title
        if (item.title) {
          ctx.font = `${18 / zoom}px "MaharamNeue-Medium", sans-serif`;
          ctx.textAlign = 'center';
          ctx.fillStyle = '#333';
          ctx.fillText(item.title, centerX, yOffset);
          yOffset += lineHeight + 5 / zoom;
        }
        
        // Brand
        if (item.brand) {
          ctx.font = `${18 / zoom}px "MaharamNeue-Medium", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.brand, centerX, yOffset);
          yOffset += lineHeight;
        }
        
        // Color
        if (item.color) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.color, centerX, yOffset);
          yOffset += lineHeight + 10 / zoom;
        }
        
        // Product Category
        if (item.productCategory) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.productCategory, centerX, yOffset);
          yOffset += lineHeight;
        }
        
        // Content
        if (item.content) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.content, centerX, yOffset);
          yOffset += lineHeight + 10 / zoom;
        }
        
        // Price
        if (item.price) {
          ctx.font = `${14 / zoom}px "MaharamNeue-Regular", sans-serif`;
          ctx.fillStyle = '#333';
          ctx.fillText(item.price, centerX, yOffset);
        }
        
        ctx.textAlign = 'left';
      } else {
        // Show image on front of card
        // Load and draw image
        if (!item.imageElement) {
          item.imageElement = new Image();
          item.imageElement.src = item.imagePath;
          item.imageElement.onload = () => draw();
        }
        
        if (item.imageElement.complete) {
          const padding = 0;
          const imgWidth = item.width - padding * 2;
          const imgHeight = item.height - padding * 2;
          
          ctx.save();
          // Clip to rounded rect for image
          ctx.beginPath();
          roundRect(ctx, item.x + padding, item.y + padding, imgWidth, imgHeight, cornerRadius);
          ctx.clip();
          
          // Calculate cover mode scaling
          const imgAspect = item.imageElement.width / item.imageElement.height;
          const boxAspect = imgWidth / imgHeight;
          
          let sourceX = 0, sourceY = 0, sourceWidth = item.imageElement.width, sourceHeight = item.imageElement.height;
          
          if (imgAspect > boxAspect) {
            // Image is wider - crop sides
            sourceWidth = item.imageElement.height * boxAspect;
            sourceX = (item.imageElement.width - sourceWidth) / 2;
          } else {
            // Image is taller - crop top/bottom
            sourceHeight = item.imageElement.width / boxAspect;
            sourceY = (item.imageElement.height - sourceHeight) / 2;
          }
          
          ctx.drawImage(
            item.imageElement,
            sourceX, sourceY, sourceWidth, sourceHeight,
            item.x + padding, item.y + padding, imgWidth, imgHeight
          );
          ctx.restore();
        }
        
        // Product name and color at bottom
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `${11 / zoom}px "MaharamNeue-Regular", sans-serif`;
        ctx.textAlign = 'center';
        const bottomText = `${item.title || 'Product'}${item.color ? ' - ' + item.color : ''}`;
        ctx.fillText(bottomText, item.x + item.width / 2, item.y + item.height - 15);
        ctx.textAlign = 'left';
      }
    }

    function drawText(item) {
      ctx.fillStyle = '#000';
      ctx.font = `${18 / zoom}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
      wrapText(ctx, item.text, item.x, item.y, item.width, 26 / zoom);
    }

    function roundRect(ctx, x, y, width, height, radius) {
      radius = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      let currentY = y;
      
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && i > 0) {
          ctx.fillText(line, x, currentY);
          line = words[i] + ' ';
          currentY += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, currentY);
    }

    // Coordinate conversion
    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - viewportX) / zoom,
        y: (screenY - viewportY) / zoom
      };
    }

    function worldToScreen(worldX, worldY) {
      return {
        x: worldX * zoom + viewportX,
        y: worldY * zoom + viewportY
      };
    }

    // Hit detection
    function getItemAtPosition(worldX, worldY) {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (worldX >= item.x && worldX <= item.x + item.width &&
            worldY >= item.y && worldY <= item.y + item.height) {
          return item;
        }
      }
      return null;
    }

    function getResizeHandle(item, worldX, worldY) {
      if (!item || item.type !== 'product') return null;
      
      const handleSize = 10 / zoom;
      const threshold = 5 / zoom;
      
      const handles = [
        { name: 'nw', x: item.x - 5, y: item.y - 5 },
        { name: 'ne', x: item.x + item.width - handleSize + 5, y: item.y - 5 },
        { name: 'sw', x: item.x - 5, y: item.y + item.height - handleSize + 5 },
        { name: 'se', x: item.x + item.width - handleSize + 5, y: item.y + item.height - handleSize + 5 }
      ];
      
      for (let handle of handles) {
        if (worldX >= handle.x - threshold && worldX <= handle.x + handleSize + threshold &&
            worldY >= handle.y - threshold && worldY <= handle.y + handleSize + threshold) {
          return handle.name;
        }
      }
      
      return null;
    }

    // Mouse events
    canvas.addEventListener('dblclick', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      const item = getItemAtPosition(world.x, world.y);
      if (item && item.type === 'product') {
        item.flipped = !item.flipped;
        draw();
      } else if (item && item.type === 'text') {
        const newText = prompt('Edit text:', item.text);
        if (newText !== null) {
          item.text = newText;
          draw();
        }
      }
    });
    
    // Context menu for right-click on products
    let contextMenuItem = null;
    
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      const item = getItemAtPosition(world.x, world.y);
      
      if (item && item.type === 'product') {
        contextMenuItem = item;
        // If clicking on an item that's already in the multi-selection, keep the selection
        if (!selectedItems.includes(item)) {
          // If not in multi-selection, make this the only selected item
          selectedItem = item;
          selectedItems = [];
        }
        showContextMenu(e.clientX, e.clientY);
        draw();
      } else {
        hideContextMenu();
      }
    });
    
    function showContextMenu(x, y) {
      const menu = document.getElementById('contextMenu');
      const count = selectedItems.length > 0 ? selectedItems.length : 1;
      const isMultiple = count > 1;
      
      // Update menu text based on selection count
      document.getElementById('contextMenuCartText').textContent = 
        isMultiple ? `Add ${count} Samples to Cart` : 'Add Sample to Cart';
      document.getElementById('contextMenuCompareText').textContent = 
        isMultiple ? `Add ${count} to Compare` : 'Add to Compare';
      document.getElementById('contextMenuFlipText').textContent = 
        isMultiple ? `Flip ${count} Cards` : 'Flip Card';
      document.getElementById('contextMenuDeleteText').textContent = 
        isMultiple ? `Delete ${count} Items` : 'Delete';
      
      menu.classList.add('active');
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
    }
    
    function hideContextMenu() {
      const menu = document.getElementById('contextMenu');
      menu.classList.remove('active');
      contextMenuItem = null;
    }
    
    function addSampleToCart() {
      const itemsToAdd = selectedItems.length > 0 ? selectedItems : [contextMenuItem];
      
      if (itemsToAdd.length > 0) {
        const productList = itemsToAdd.map(p => `${p.title} - ${p.brand} - ${p.color}`).join('\n');
        alert(`${itemsToAdd.length} sample${itemsToAdd.length > 1 ? 's' : ''} added to cart:\n\n${productList}`);
        console.log('Added to cart:', itemsToAdd);
      }
      hideContextMenu();
    }
    
    function addToCompare() {
      const itemsToAdd = selectedItems.length > 0 ? selectedItems : [contextMenuItem];
      
      if (itemsToAdd.length > 0) {
        const productList = itemsToAdd.map(p => `${p.title} - ${p.brand} - ${p.color}`).join('\n');
        alert(`${itemsToAdd.length} product${itemsToAdd.length > 1 ? 's' : ''} added to compare:\n\n${productList}`);
        console.log('Added to compare:', itemsToAdd);
      }
      hideContextMenu();
    }
    
    function flipSelectedProduct() {
      const itemsToFlip = selectedItems.length > 0 ? selectedItems : [contextMenuItem];
      
      itemsToFlip.forEach(item => {
        if (item && item.type === 'product') {
          item.flipped = !item.flipped;
        }
      });
      
      draw();
      hideContextMenu();
    }
    
    // Close context menu when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.context-menu')) {
        hideContextMenu();
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      if (currentTool === 'select') {
        // Check if clicking on a resize handle first
        if (selectedItem && selectedItem.type === 'product') {
          const handle = getResizeHandle(selectedItem, world.x, world.y);
          if (handle) {
            isResizing = true;
            resizeHandle = handle;
            resizeStartX = world.x;
            resizeStartY = world.y;
            resizeStartWidth = selectedItem.width;
            resizeStartHeight = selectedItem.height;
            return;
          }
        }
        
        const item = getItemAtPosition(world.x, world.y);
        
        if (item) {
          // Handle shift-click for multi-selection
          if (e.shiftKey && item.type === 'product') {
            if (selectedItems.includes(item)) {
              // Remove from selection
              selectedItems = selectedItems.filter(i => i !== item);
              if (selectedItems.length === 0) {
                selectedItem = null;
              }
            } else {
              // Add to selection
              selectedItems.push(item);
              selectedItem = item;
            }
          } else {
            // Regular single selection
            selectedItem = item;
            selectedItems = [];
            draggedItem = item;
            dragOffsetX = world.x - item.x;
            dragOffsetY = world.y - item.y;
          }
          
          // Move to front
          items.splice(items.indexOf(item), 1);
          items.push(item);
        } else {
          selectedItem = null;
          selectedItems = [];
          isDragging = true;
          dragStartX = mouseX;
          dragStartY = mouseY;
        }
      } else {
        // Check if clicking on existing text item when text tool is selected
        const item = getItemAtPosition(world.x, world.y);
        if (currentTool === 'text' && item && item.type === 'text') {
          // Edit existing text item
          const newText = prompt('Edit text:', item.text);
          if (newText !== null) {
            item.text = newText;
            selectedItem = item;
          }
          draw();
          return; // Don't add new item
        } else {
          // Add new item
          addItem(currentTool, world.x, world.y);
        }
      }
      
      draw();
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const world = screenToWorld(mouseX, mouseY);
      
      if (isDragging) {
        const dx = mouseX - dragStartX;
        const dy = mouseY - dragStartY;
        viewportX += dx;
        viewportY += dy;
        dragStartX = mouseX;
        dragStartY = mouseY;
        draw();
      } else if (isResizing && selectedItem) {
        const dx = world.x - resizeStartX;
        const dy = world.y - resizeStartY;
        const minSize = 100;
        
        if (resizeHandle === 'se') {
          selectedItem.width = Math.max(minSize, resizeStartWidth + dx);
          selectedItem.height = Math.max(minSize, resizeStartHeight + dy);
        } else if (resizeHandle === 'sw') {
          const newWidth = Math.max(minSize, resizeStartWidth - dx);
          if (newWidth > minSize) {
            selectedItem.x = selectedItem.x + (selectedItem.width - newWidth);
          }
          selectedItem.width = newWidth;
          selectedItem.height = Math.max(minSize, resizeStartHeight + dy);
        } else if (resizeHandle === 'ne') {
          selectedItem.width = Math.max(minSize, resizeStartWidth + dx);
          const newHeight = Math.max(minSize, resizeStartHeight - dy);
          if (newHeight > minSize) {
            selectedItem.y = selectedItem.y + (selectedItem.height - newHeight);
          }
          selectedItem.height = newHeight;
        } else if (resizeHandle === 'nw') {
          const newWidth = Math.max(minSize, resizeStartWidth - dx);
          const newHeight = Math.max(minSize, resizeStartHeight - dy);
          if (newWidth > minSize) {
            selectedItem.x = selectedItem.x + (selectedItem.width - newWidth);
          }
          if (newHeight > minSize) {
            selectedItem.y = selectedItem.y + (selectedItem.height - newHeight);
          }
          selectedItem.width = newWidth;
          selectedItem.height = newHeight;
        }
        
        draw();
      } else if (draggedItem) {
        draggedItem.x = world.x - dragOffsetX;
        draggedItem.y = world.y - dragOffsetY;
        draw();
      } else {
        // Update cursor based on hover
        if (selectedItem && selectedItem.type === 'product') {
          const handle = getResizeHandle(selectedItem, world.x, world.y);
          if (handle) {
            canvas.style.cursor = handle + '-resize';
            return;
          }
        }
        const item = getItemAtPosition(world.x, world.y);
        canvas.style.cursor = item ? 'move' : 'grab';
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      draggedItem = null;
      isResizing = false;
      resizeHandle = null;
      canvas.style.cursor = 'grab';
    });

    // Zoom
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      const worldBeforeZoom = screenToWorld(mouseX, mouseY);
      
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      zoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
      
      const worldAfterZoom = screenToWorld(mouseX, mouseY);
      
      viewportX += (worldAfterZoom.x - worldBeforeZoom.x) * zoom;
      viewportY += (worldAfterZoom.y - worldBeforeZoom.y) * zoom;
      
      draw();
    }, { passive: false });

    // Tool selection
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const tool = btn.dataset.tool;
        if (tool === 'product') {
          openProductModal();
        } else {
          document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentTool = tool;
        }
      });
    });

    // Controls
    document.getElementById('zoomIn').addEventListener('click', () => {
      zoom = Math.min(5, zoom * 1.2);
      draw();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      zoom = Math.max(0.1, zoom / 1.2);
      draw();
    });

    document.getElementById('resetView').addEventListener('click', () => {
      viewportX = 0;
      viewportY = 0;
      zoom = 1;
      draw();
    });

    document.getElementById('deleteItem').addEventListener('click', () => {
      deleteSelectedItem();
    });

    // Delete selected item function
    function deleteSelectedItem() {
      const itemsToDelete = selectedItems.length > 0 ? selectedItems : [selectedItem];
      
      itemsToDelete.forEach(item => {
        if (item) {
          const index = items.indexOf(item);
          if (index > -1) {
            items.splice(index, 1);
          }
        }
      });
      
      selectedItem = null;
      selectedItems = [];
      updateProjectsList();
      updatePalettesList();
      draw();
      hideContextMenu();
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      // Delete or Backspace key
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItem) {
        e.preventDefault();
        deleteSelectedItem();
      }
    });

    // Add new items
    function addItem(type, x, y) {
      const colors = ['#FFE680', '#FF9E9E', '#A0D8FF', '#B4E7CE', '#E7B4E7', '#FFD4A3'];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      
      let newItem;
      
      if (type === 'product') {
        const randomProduct = productsData[Math.floor(Math.random() * productsData.length)];
        
        newItem = {
          type: 'product',
          x: x - 125,
          y: y - 125,
          width: 250,
          height: 250,
          imagePath: randomProduct.imagePath,
          title: randomProduct.title,
          brand: randomProduct.brand,
          color: randomProduct.colorCode,
          productCategory: randomProduct.productCategory,
          content: randomProduct.content,
          price: randomProduct.price,
          flipped: false,
          id: generateId()
        };
      } else if (type === 'text') {
        const textContent = prompt('Enter text:', 'Click to edit text');
        if (textContent === null) {
          return; // User cancelled
        }
        newItem = {
          type: 'text',
          x: x,
          y: y,
          width: 300,
          height: 80,
          text: textContent,
          id: generateId()
        };
      }
      
      if (newItem) {
        items.push(newItem);
        selectedItem = newItem;
        draw();
      }
    }

    // Product Modal functionality
    let allProductsData = [];
    
    function openProductModal() {
      const modal = document.getElementById('productModal');
      
      // Build product data array
      allProductsData = productsData.map(product => ({
        imagePath: product.imagePath,
        productName: product.title,
        brand: product.brand,
        colorCode: product.colorCode,
        category: product.productCategory
      }));
      
      // Populate filter dropdowns
      populateFilters();
      
      // Display all products
      renderProducts(allProductsData);
      
      modal.classList.add('active');
    }
    
    function populateFilters() {
      // Get unique values
      const brands = [...new Set(allProductsData.map(p => p.brand))].sort();
      const categories = [...new Set(allProductsData.map(p => p.category))].sort();
      const colors = [...new Set(allProductsData.map(p => p.colorCode))].filter(c => c).sort();
      
      // Populate brand filter
      const brandSelect = document.getElementById('filterBrand');
      brandSelect.innerHTML = '<option value="all">All Brands</option>';
      brands.forEach(brand => {
        const option = document.createElement('option');
        option.value = brand;
        option.textContent = brand;
        brandSelect.appendChild(option);
      });
      
      // Populate category filter
      const categorySelect = document.getElementById('filterCategory');
      categorySelect.innerHTML = '<option value="all">All Categories</option>';
      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
      });
      
      // Populate color filter
      const colorSelect = document.getElementById('filterColor');
      colorSelect.innerHTML = '<option value="all">All Colors</option>';
      colors.forEach(color => {
        const option = document.createElement('option');
        option.value = color;
        option.textContent = color;
        colorSelect.appendChild(option);
      });
    }
    
    function applyFilters() {
      const brandFilter = document.getElementById('filterBrand').value;
      const categoryFilter = document.getElementById('filterCategory').value;
      const colorFilter = document.getElementById('filterColor').value;
      const searchQuery = document.getElementById('productSearch').value.toLowerCase();
      
      let filtered = allProductsData;
      
      if (brandFilter !== 'all') {
        filtered = filtered.filter(p => p.brand === brandFilter);
      }
      
      if (categoryFilter !== 'all') {
        filtered = filtered.filter(p => p.category === categoryFilter);
      }
      
      if (colorFilter !== 'all') {
        filtered = filtered.filter(p => p.colorCode === colorFilter);
      }
      
      if (searchQuery) {
        filtered = filtered.filter(p => 
          p.productName.toLowerCase().includes(searchQuery) ||
          p.brand.toLowerCase().includes(searchQuery) ||
          p.colorCode.toLowerCase().includes(searchQuery)
        );
      }
      
      renderProducts(filtered);
    }
    
    function renderProducts(products) {
      const productGrid = document.getElementById('productGrid');
      productGrid.innerHTML = '';
      
      products.forEach(product => {
        const card = document.createElement('div');
        card.className = 'product-card';
        card.onclick = () => selectProduct(product.imagePath);
        
        card.innerHTML = `
          <img src="${product.imagePath}" alt="${product.productName}">
          <div class="product-card-title">${product.productName}</div>
          <div class="product-card-info">${product.brand} - ${product.colorCode}</div>
        `;
        
        productGrid.appendChild(card);
      });
    }
    
    function closeProductModal() {
      const modal = document.getElementById('productModal');
      modal.classList.remove('active');
    }
    
    function selectProduct(imagePath) {
      closeProductModal();
      
      const fileName = imagePath.split('/').pop();
      const parts = fileName.replace('_detail.jpg', '').split('_');
      const brandCode = parts[0];
      const productName = parts[1] || 'Product';
      const colorCode = parts[2] || '';
      const brand = brandCode === 'KT' ? 'Knoll Textiles' : 
                   brandCode === 'MHRM' ? 'Maharam' : 
                   'Maharam';
      
      const rect = canvas.getBoundingClientRect();
      const centerX = (rect.width / 2 - viewportX) / zoom;
      const centerY = (rect.height / 2 - viewportY) / zoom;
      
      const newItem = {
        type: 'product',
        x: centerX - 125,
        y: centerY - 125,
        width: 250,
        height: 250,
        imagePath: imagePath,
        title: productName,
        brand: brand,
        color: colorCode,
        productCategory: 'Upholstery',
        content: 'Textile',
        price: '$85.00 / yd',
        flipped: false,
        id: generateId()
      };
      
      items.push(newItem);
      selectedItem = newItem;
      
      if (!newItem.projectId) {
        newItem.projectId = projects[0].id;
      }
      
      updateProjectsList();
      draw();
    }
    
    // Close modal when clicking outside
    document.getElementById('productModal').addEventListener('click', (e) => {
      if (e.target.id === 'productModal') {
        closeProductModal();
      }
    });

    // Sidebar functionality
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebarToggle');
    let sidebarOpen = false;

    sidebarToggle.addEventListener('click', () => {
      sidebarOpen = !sidebarOpen;
      sidebar.classList.toggle('open');
      sidebarToggle.classList.toggle('open');
      sidebarToggle.textContent = sidebarOpen ? '‚úï' : '‚ò∞';
    });

    // Projects/Folders system
    let projectsSectionExpanded = true;
    
    const projects = [
      { id: 'default', name: 'My Project', expanded: true, items: [] },
      { id: 'ideas', name: 'Ideas', expanded: false, items: [] }
    ];
    
    function toggleProjectsSection() {
      projectsSectionExpanded = !projectsSectionExpanded;
      const content = document.getElementById('projectsSectionContent');
      const icon = document.getElementById('projectsSectionIcon');
      
      if (projectsSectionExpanded) {
        content.style.display = 'block';
        icon.textContent = 'üìÇ';
      } else {
        content.style.display = 'none';
        icon.textContent = 'üìÅ';
      }
    }

    // Assign initial items to default project
    items.forEach(item => {
      if (!item.projectId) {
        item.projectId = 'default';
      }
    });

    // Palettes/Folders system
    let palettesSectionExpanded = true;
    
    const palettes = [
      { id: 'palette1', name: 'Warm Tones', expanded: true, items: [] },
      { id: 'palette2', name: 'Cool Colors', expanded: false, items: [] },
      { id: 'palette3', name: 'Neutrals', expanded: false, items: [] }
    ];
    
    function togglePalettesSection() {
      palettesSectionExpanded = !palettesSectionExpanded;
      const content = document.getElementById('palettesSectionContent');
      const icon = document.getElementById('palettesSectionIcon');
      
      if (palettesSectionExpanded) {
        content.style.display = 'block';
        icon.textContent = 'üìÇ';
      } else {
        content.style.display = 'none';
        icon.textContent = 'üìÅ';
      }
    }

    function createNewPalette() {
      const paletteName = prompt('Enter palette name:', 'New Palette');
      if (paletteName) {
        const newPalette = {
          id: generateId(),
          name: paletteName,
          expanded: true,
          items: []
        };
        palettes.push(newPalette);
        updatePalettesList();
      }
    }

    function deletePalette(paletteId) {
      if (confirm('Delete this palette and all its items?')) {
        const paletteIndex = palettes.findIndex(p => p.id === paletteId);
        if (paletteIndex > -1) {
          // Remove all items in this palette
          for (let i = items.length - 1; i >= 0; i--) {
            if (items[i].paletteId === paletteId) {
              items.splice(i, 1);
            }
          }
          palettes.splice(paletteIndex, 1);
          selectedItem = null;
          updatePalettesList();
          updateProjectsList();
          draw();
        }
      }
    }

    function renamePalette(paletteId) {
      const palette = palettes.find(p => p.id === paletteId);
      if (palette) {
        const newName = prompt('Enter new palette name:', palette.name);
        if (newName) {
          palette.name = newName;
          updatePalettesList();
        }
      }
    }

    function togglePalette(paletteId) {
      const palette = palettes.find(p => p.id === paletteId);
      if (palette) {
        palette.expanded = !palette.expanded;
        updatePalettesList();
      }
    }

    // Update palettes list
    function updatePalettesList() {
      const palettesList = document.getElementById('palettesList');
      palettesList.innerHTML = '';
      
      palettes.forEach(palette => {
        const paletteFolder = document.createElement('div');
        paletteFolder.className = 'project-folder';
        
        // Make folder a drop target
        paletteFolder.ondragover = (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          paletteFolder.style.background = '#e3f2fd';
        };
        paletteFolder.ondragleave = (e) => {
          if (!paletteFolder.contains(e.relatedTarget)) {
            paletteFolder.style.background = '';
          }
        };
        paletteFolder.ondrop = (e) => {
          e.preventDefault();
          paletteFolder.style.background = '';
          const itemId = e.dataTransfer.getData('text/plain');
          const draggedItem = items.find(item => item.id === itemId);
          if (draggedItem) {
            draggedItem.paletteId = palette.id;
            updatePalettesList();
            updateProjectsList();
          }
        };
        
        const paletteHeader = document.createElement('div');
        paletteHeader.className = 'project-header';
        
        const paletteTitle = document.createElement('div');
        paletteTitle.className = 'project-title';
        
        const paletteItems = items.filter(item => item.paletteId === palette.id);
        const expandIcon = palette.expanded ? 'üìÇ' : 'üìÅ';
        
        paletteTitle.innerHTML = `${expandIcon} ${palette.name} (${paletteItems.length})`;
        paletteTitle.onclick = () => togglePalette(palette.id);
        
        const paletteActions = document.createElement('div');
        paletteActions.className = 'project-actions';
        
        const renameBtn = document.createElement('button');
        renameBtn.className = 'project-action-btn';
        renameBtn.innerHTML = '‚úèÔ∏è';
        renameBtn.title = 'Rename';
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          renamePalette(palette.id);
        };
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'project-action-btn';
        deleteBtn.innerHTML = 'üóëÔ∏è';
        deleteBtn.title = 'Delete';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deletePalette(palette.id);
        };
        
        paletteActions.appendChild(renameBtn);
        paletteActions.appendChild(deleteBtn);
        
        paletteHeader.appendChild(paletteTitle);
        paletteHeader.appendChild(paletteActions);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'project-items';
        if (palette.expanded) {
          itemsContainer.classList.add('expanded');
        }
        
        paletteItems.forEach(item => {
          const paletteItem = document.createElement('div');
          paletteItem.className = 'project-item';
          if (selectedItem === item) {
            paletteItem.classList.add('selected');
          }
          
          const icon = item.type === 'product' ? 'üñºÔ∏è' : 'üìÑ';
          const text = item.type === 'product' ? (item.title || 'Product') : 
                       item.text.substring(0, 20);
          
          paletteItem.innerHTML = `${icon} ${text}${text.length >= 20 ? '...' : ''}`;
          paletteItem.onclick = () => {
            selectedItem = item;
            updatePalettesList();
            updateProjectsList();
            draw();
          };
          
          // Make item draggable
          paletteItem.draggable = true;
          paletteItem.ondragstart = (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', item.id);
            paletteItem.style.opacity = '0.5';
          };
          paletteItem.ondragend = (e) => {
            paletteItem.style.opacity = '1';
          };
          
          // Add context menu for moving items
          paletteItem.oncontextmenu = (e) => {
            e.preventDefault();
            showPaletteItemContextMenu(e, item);
          };
          
          itemsContainer.appendChild(paletteItem);
        });
        
        paletteFolder.appendChild(paletteHeader);
        paletteFolder.appendChild(itemsContainer);
        palettesList.appendChild(paletteFolder);
      });
    }

    function showPaletteItemContextMenu(e, item) {
      const moveToMenu = prompt('Move to palette (enter palette name):\n' + 
        palettes.map(p => `- ${p.name}`).join('\n'));
      
      if (moveToMenu) {
        const targetPalette = palettes.find(p => 
          p.name.toLowerCase() === moveToMenu.toLowerCase()
        );
        if (targetPalette) {
          item.paletteId = targetPalette.id;
          updatePalettesList();
          updateProjectsList();
        }
      }
    }

    function createNewProject() {
      const projectName = prompt('Enter project name:', 'New Project');
      if (projectName) {
        const newProject = {
          id: generateId(),
          name: projectName,
          expanded: true,
          items: []
        };
        projects.push(newProject);
        updateProjectsList();
      }
    }

    function deleteProject(projectId) {
      if (confirm('Delete this project and all its items?')) {
        const projectIndex = projects.findIndex(p => p.id === projectId);
        if (projectIndex > -1) {
          // Remove all items in this project
          for (let i = items.length - 1; i >= 0; i--) {
            if (items[i].projectId === projectId) {
              items.splice(i, 1);
            }
          }
          projects.splice(projectIndex, 1);
          selectedItem = null;
          updateProjectsList();
          draw();
        }
      }
    }

    function renameProject(projectId) {
      const project = projects.find(p => p.id === projectId);
      if (project) {
        const newName = prompt('Enter new project name:', project.name);
        if (newName) {
          project.name = newName;
          updateProjectsList();
        }
      }
    }

    function toggleProject(projectId) {
      const project = projects.find(p => p.id === projectId);
      if (project) {
        project.expanded = !project.expanded;
        updateProjectsList();
      }
    }

    // Update projects list
    function updateProjectsList() {
      const projectsList = document.getElementById('projectsList');
      projectsList.innerHTML = '';
      
      projects.forEach(project => {
        const projectFolder = document.createElement('div');
        projectFolder.className = 'project-folder';
        
        // Make folder a drop target
        projectFolder.ondragover = (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          projectFolder.style.background = '#e3f2fd';
        };
        projectFolder.ondragleave = (e) => {
          if (!projectFolder.contains(e.relatedTarget)) {
            projectFolder.style.background = '';
          }
        };
        projectFolder.ondrop = (e) => {
          e.preventDefault();
          projectFolder.style.background = '';
          const itemId = e.dataTransfer.getData('text/plain');
          const draggedItem = items.find(item => item.id === itemId);
          if (draggedItem) {
            draggedItem.projectId = project.id;
            delete draggedItem.paletteId; // Remove from palette if it was there
            updateProjectsList();
            updatePalettesList();
          }
        };
        
        const projectHeader = document.createElement('div');
        projectHeader.className = 'project-header';
        
        const projectTitle = document.createElement('div');
        projectTitle.className = 'project-title';
        
        const projectItems = items.filter(item => item.projectId === project.id);
        const expandIcon = project.expanded ? 'üìÇ' : 'üìÅ';
        
        projectTitle.innerHTML = `${expandIcon} ${project.name} (${projectItems.length})`;
        projectTitle.onclick = () => toggleProject(project.id);
        
        const projectActions = document.createElement('div');
        projectActions.className = 'project-actions';
        
        const renameBtn = document.createElement('button');
        renameBtn.className = 'project-action-btn';
        renameBtn.innerHTML = '‚úèÔ∏è';
        renameBtn.title = 'Rename';
        renameBtn.onclick = (e) => {
          e.stopPropagation();
          renameProject(project.id);
        };
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'project-action-btn';
        deleteBtn.innerHTML = 'üóëÔ∏è';
        deleteBtn.title = 'Delete';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteProject(project.id);
        };
        
        projectActions.appendChild(renameBtn);
        projectActions.appendChild(deleteBtn);
        
        projectHeader.appendChild(projectTitle);
        projectHeader.appendChild(projectActions);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'project-items';
        if (project.expanded) {
          itemsContainer.classList.add('expanded');
        }
        
        projectItems.forEach(item => {
          const projectItem = document.createElement('div');
          projectItem.className = 'project-item';
          if (selectedItem === item) {
            projectItem.classList.add('selected');
          }
          
          const icon = item.type === 'product' ? 'üñºÔ∏è' : 'üìÑ';
          const text = item.type === 'product' ? (item.title || 'Product') : 
                       item.text.substring(0, 20);
          
          projectItem.innerHTML = `${icon} ${text}${text.length >= 20 ? '...' : ''}`;
          projectItem.onclick = () => {
            selectedItem = item;
            updateProjectsList();
            draw();
          };
          
          // Make item draggable
          projectItem.draggable = true;
          projectItem.ondragstart = (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', item.id);
            projectItem.style.opacity = '0.5';
          };
          projectItem.ondragend = (e) => {
            projectItem.style.opacity = '1';
          };
          
          // Add context menu for moving items
          projectItem.oncontextmenu = (e) => {
            e.preventDefault();
            showItemContextMenu(e, item);
          };
          
          itemsContainer.appendChild(projectItem);
        });
        
        projectFolder.appendChild(projectHeader);
        projectFolder.appendChild(itemsContainer);
        projectsList.appendChild(projectFolder);
      });
    }

    function showItemContextMenu(e, item) {
      const moveToMenu = prompt('Move to project (enter project name):\n' + 
        projects.map(p => `- ${p.name}`).join('\n'));
      
      if (moveToMenu) {
        const targetProject = projects.find(p => 
          p.name.toLowerCase() === moveToMenu.toLowerCase()
        );
        if (targetProject) {
          item.projectId = targetProject.id;
          updateProjectsList();
        }
      }
    }

    // Setup color palette
    function setupColorPalette() {
      const colors = ['#FFE680', '#FF9E9E', '#A0D8FF', '#B4E7CE', '#E7B4E7', '#FFD4A3'];
      const colorPalette = document.getElementById('colorPalette');
      
      colors.forEach(color => {
        const swatch = document.createElement('div');
        swatch.className = 'sidebar-item';
        swatch.style.padding = '0';
        swatch.style.height = '40px';
        swatch.style.display = 'flex';
        swatch.style.alignItems = 'center';
        swatch.style.justifyContent = 'center';
        
        const colorDiv = document.createElement('div');
        colorDiv.className = 'color-swatch';
        colorDiv.style.backgroundColor = color;
        colorDiv.style.width = '100%';
        colorDiv.style.height = '100%';
        colorDiv.style.borderRadius = '6px';
        
        swatch.appendChild(colorDiv);
        
        colorPalette.appendChild(swatch);
      });
    }

    // Clean up grid - arrange products in a grid layout with animation
    function cleanUpGrid() {
      const products = items.filter(item => item.type === 'product');
      if (products.length === 0) return;
      
      const gridSpacing = 30;
      const startX = 100;
      const startY = 100;
      
      // Find the most common width to use as standard
      const widths = products.map(p => p.width);
      const avgWidth = widths.reduce((a, b) => a + b, 0) / widths.length;
      const avgHeight = products.reduce((sum, p) => sum + p.height, 0) / products.length;
      
      // Calculate columns based on canvas width
      const canvasWidth = canvas.getBoundingClientRect().width / zoom;
      const itemWidthWithSpacing = avgWidth + gridSpacing;
      const columns = Math.floor((canvasWidth - startX * 2) / itemWidthWithSpacing) || 3;
      
      // Store start and end positions for animation
      const animations = products.map((product, index) => {
        const col = index % columns;
        const row = Math.floor(index / columns);
        
        return {
          product: product,
          startX: product.x,
          startY: product.y,
          endX: startX + col * (avgWidth + gridSpacing),
          endY: startY + row * (avgHeight + gridSpacing)
        };
      });
      
      // Animate to grid positions
      const duration = 500; // milliseconds
      const startTime = performance.now();
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function (ease-out cubic)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        animations.forEach(anim => {
          anim.product.x = anim.startX + (anim.endX - anim.startX) * easeProgress;
          anim.product.y = anim.startY + (anim.endY - anim.startY) * easeProgress;
        });
        
        draw();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          updateProjectsList();
        }
      }
      
      requestAnimationFrame(animate);
    }

    // Clear canvas
    function clearCanvas() {
      if (confirm('Are you sure you want to clear the canvas?')) {
        items.length = 0;
        selectedItem = null;
        updateProjectsList();
        draw();
      }
    }

    // Export canvas
    function exportCanvas() {
      const link = document.createElement('a');
      link.download = 'canvas-export.png';
      link.href = canvas.toDataURL();
      link.click();
    }

    // Initialize sidebar
    // setupColorPalette();
    updateProjectsList();
    updatePalettesList();
    
    // Load product data
    loadProductData();

    // Update projects list when items change
    const originalAddItem = addItem;
    addItem = function(type, x, y) {
      originalAddItem(type, x, y);
      // Assign to first project by default
      if (items.length > 0 && !items[items.length - 1].projectId) {
        items[items.length - 1].projectId = projects[0].id;
      }
      updateProjectsList();
    };
    
    // Load product data
    loadProductData();

    // Initial draw
    draw();
  </script>
</body>
</html>